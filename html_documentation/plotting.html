<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>plotting API documentation</title>
<meta name="description" content="Application: OSPEX in Python â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>plotting</code></h1>
</header>
<section id="section-intro">
<p>Application: OSPEX in Python</p>
<p>Start date: 11/03/2019</p>
<p>Creators: Liaisian Abdrakhmanova, Abdallah Hamini, Aichatou Aboubacar</p>
<p>Organization: LESIA, Observatory of Paris, France</p>
<p>Graphical User Interface: GUI was created using tkinter library</p>
<p>Usage: information to test the program provided in Requirements file</p>
<p>Status = 'Development'</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

   Application: OSPEX in Python

   Start date: 11/03/2019

   Creators: Liaisian Abdrakhmanova, Abdallah Hamini, Aichatou Aboubacar

   Organization: LESIA, Observatory of Paris, France
  
   Graphical User Interface: GUI was created using tkinter library

   Usage: information to test the program provided in Requirements file

   Status = &#39;Development&#39;

&#34;&#34;&#34;
 
import numpy as np
import pandas as pd
from astropy.io import fits
from matplotlib import pyplot as plt
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()
#from matplotlib import rcParams
#rcParams[&#39;font.family&#39;] = &#39;sans-serif&#39;
#rcParams[&#39;font.sans-serif&#39;] = [&#39;DejaVu Sans&#39;]
from datetime import timedelta


class Input():
    &#34;&#34;&#34;Class to load the parameters from input data and plot Spectrum, Time Profile and Spectrogram.
       Called Units: Rate, Counts, Flux.&#34;&#34;&#34;
  
    def __init__(self, file):
        &#34;&#34;&#34;When open the .fits file, the returned object, called hdulist, behaves like a Python list and each element maps
        to a Header - Data Unit(HDU). We are primarily interested in RATE extension which contains the spectral data.
        Extracted object has two important attributes: data, which behaves like an array, can be used to access to the numerical data;
        and header, which behaves like a dictionary, can be used to access to the header information&#34;&#34;&#34;
        data1, data2, header3, header1 = self.__load_data(file) 

        # Define the parameters from HEADER and DATA
        # access by keywords
        self.rate = data1.RATE # count rate data in each energy channel
        self.Time = data1.TIME # array of Time(in seconds) corresponds to the observed flare
        self.Time2 = data1.TIME - 2 # FIXME: used to scale the X - axis in Time profile and Spectrogram plots - 2 seconds difference
        self.Time_del = data1.TIMEDEL # accumulation time
        self.Channel = data1.CHANNEL # energy channels
        self.E_min = data2.E_MIN # array of Low energies
        self.E_max = data2.E_MAX # array of High energies
        self.time_len = len(self.Time) # time length (time bins) 
        self.Area = header3[24] # load the area from header 
        self.Date_start = header3[17] # load start date from header
        self.Date_end = header3[18] # load end date from header
        self.E1 = self.E_min[3] - self.E_min[0] # highlight energy range from 3 to 6 kEv
        self.E2 = self.E_min[9] - self.E_min[3] # highlight energy range from 6 to 12 kEv
        self.E3 = self.E_min[22] - self.E_min[9] # highlight energy range from 12 to 25 kEv
        self.E4 = self.E_min[40] - self.E_min[22] # highlight energy range from 25 to 49 kEv
        self.E5 = self.E_min[57] - self.E_min[40] # highlight energy range from 49 to 100 kEv
        self.E6 = self.E_min[76] - self.E_min[57] # highlight energy range from 100 to 250 kEv
        self.sum = sum(self.Time_del) # observed event duration (in seconds)
        self.detectors = str(header1[25])[10:] # load the names of used detectors 

        # Time format conversion for Time - 2, 2 seconds difference
        # conversion from seconds to hours/minutes/seconds
        self.TimeNew2 = pd.to_datetime(self.Time2, unit=&#39;s&#39;)

    def __load_data(self, file):
        &#34;&#34;&#34;Loading the input file choosen in &#39;Select Input&#39; section&#34;&#34;&#34;
        hdulist = fits.open(file) # read the data
        hdulist.info() # display the content of the read file
        return hdulist[1].data, hdulist[2].data, hdulist[1].header, hdulist[3].header  #read the Data and Header contents from input file

################### 1. Time Profile Plotting ####################

    def __get_rate_data(self):
        &#34;&#34;&#34;Define the Rate for &#34;Plot Time Profile&#34;
        Rate  = array which has a count rate data for each energy channel
        There are 6 energy channels
        1: 3-6 kEV
        2: 6-12 keV
        3: 12-25 keV
        4: 25-49 keV
        5: 49-100 keV
        6: 100-250 keV &#34;&#34;&#34;
        data = np.zeros(shape=(self.time_len, 6))
        for i in range(self.time_len):
            # determine the energy distribution for different channels relative to the time of observed data
            data[i, 0] = sum(self.rate[i, 0:3]) #energy channel = 3-6 kEV
            data[i, 1] = sum(self.rate[i, 3:9]) #6-12 keV
            data[i, 2] = sum(self.rate[i, 9:22]) #12-25 keV
            data[i, 3] = sum(self.rate[i, 22:40]) #25-49 keV
            data[i, 4] = sum(self.rate[i, 40:57]) #49-100 keV
            data[i, 5] = sum(self.rate[i, 57:76]) #100-250 keV
        return data #return Rate unit

    def __get_counts_data(self):
        &#34;&#34;&#34;Define the Counts for &#34;Plot Time Profile&#34;
        In order to perform the conversion between Rate and Counts, multiply accumulation time by Rate&#34;&#34;&#34;
        data = np.zeros(shape=(self.time_len, 6))
        for i in range(self.time_len):
            data[i, 0] = sum(self.rate[i, 0:3]) * self.Time_del[i]
            data[i, 1] = sum(self.rate[i, 3:9]) * self.Time_del[i]
            data[i, 2] = sum(self.rate[i, 9:22]) * self.Time_del[i]
            data[i, 3] = sum(self.rate[i, 22:40]) * self.Time_del[i]
            data[i, 4] = sum(self.rate[i, 40:57]) * self.Time_del[i]
            data[i, 5] = sum(self.rate[i, 57:76]) * self.Time_del[i]
        return data #return Counts unit

    def __get_flux_data(self):
        &#34;&#34;&#34;Define the Flux for &#34;Plot Time Profile&#34;
        In order to convert Rate to count flux, divide the Rate by Area and Energy bin width&#34;&#34;&#34;
        data = np.zeros(shape=(self.time_len, 6))
        for i in range(self.time_len):
            data[i, 0] = sum(self.rate[i, 0:3]) / (self.Area * self.E1)
            data[i, 1] = sum(self.rate[i, 3:9]) / (self.Area * self.E2)
            data[i, 2] = sum(self.rate[i, 9:22]) / (self.Area * self.E3)
            data[i, 3] = sum(self.rate[i, 22:40]) / (self.Area * self.E4)
            data[i, 4] = sum(self.rate[i, 40:57]) / (self.Area * self.E5)
            data[i, 5] = sum(self.rate[i, 57:76]) / (self.Area * self.E6)
        return data #return Flux unit

    

    # 1. Plot Time Profile for Rate, Counts, Flux
    def __time_profile_plotting(self, data, xlabel, title, show=True, name=None):
        &#34;&#34;&#34;Plotting the function of time by selected Unit&#34;&#34;&#34;
        df = pd.DataFrame(data, index=self.TimeNew2,
                          columns=[&#39;3-6keV(Data with Bk)&#39;, &#39;6-12keV(Data with Bk)&#39;, &#39;12-25keV(Data with Bk)&#39;,
                                   &#39;25-49keV(Data with Bk)&#39;, &#39;49-100keV(Data with Bk)&#39;, &#39;100-250keV(Data with Bk)&#39;]) # add labels for each energy channel
        colors = [&#39;gray&#39;,&#39;magenta&#39;,&#39;lime&#39;, &#39;cyan&#39;, &#39;yellow&#39;, &#39;red&#39;] #choose the specific color for each energy channel 
        #df.style.set_properties(subset=[&#39;columns&#39;], **{&#39;height&#39;: &#39;50px&#39;})
        df.plot(figsize=(6, 6), drawstyle=&#39;steps-post&#39;, color = colors) # set the size of the figure 
        # define where the steps should be placed: &#39;steps-pre&#39;: The y value is continued constantly to the left from
        # every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]
        # &#39;steps-post&#39;: The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i]
        # &#39;steps-mid&#39;: Steps occur half-way between the x positions
        #plt.rc(&#39;legend&#39;, labelsize=6)
        plt.yscale(&#39;log&#39;) # set Y-axis in log
        plt.xlabel(&#39;Start time: &#39; + str(self.Date_start)) # load start time from header and display it in X - axis
        plt.ylabel(xlabel)
        plt.title(title)
        #plt.text(self.x_position, 166, &#39;Detectors: &#39; + self.detectors) #rate
        #plt.text(self.x_position, 664, &#39;Detectors: &#39; + self.detectors)  # counts
        #plt.text(self.x_position, 0.023, &#39;Detectors: &#39; + self.detectors) #flux
        if show:
            plt.show()
        if name:
            plt.savefig(name, format=&#39;png&#39;)

    # if Rate, plot:
    def rate_vs_time_plotting(self):
        &#34;&#34;&#34;If user pick Rate in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
        rate_data = self.__get_rate_data()
        self.__time_profile_plotting(rate_data, &#39;counts/s&#39;, &#39;SPEX HESSI Count Rate vs Time&#39;) # name Y -axis and title for Rate 

    # if Counts:
    def counts_vs_time_plotting(self):
        &#34;&#34;&#34;If user pick Counts in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
        count_data = self.__get_counts_data()

        self.__time_profile_plotting(count_data, &#39;counts&#39;, &#39;SPEX HESSI Counts vs Time&#39;) # name Y -axis and title for Counts 

    # if Flux:
    def flux_vs_time_plotting(self):
        &#34;&#34;&#34;If user pick Flux in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
        flux_data = self.__get_flux_data()
        self.__time_profile_plotting(flux_data, &#39;counts s^(-1) cm^(-2) keV^(-1)&#39;, &#39;SPEX HESSI Count Flux vs Time&#39;) # name Y -axis and title for Flux

############################# 2. Spectrum plotting #################

    def __plot_spectrum(self, typ):
        &#34;&#34;&#34;As a photons come in over the time and with different energies, the spectrum of counts is built up
        Spectrum = function of energies for Rate/Counts/Flux&#34;&#34;&#34;
        n = len(self.E_min)
        data = np.zeros(shape=n) 
        if typ == &#39;rate&#39;:
            plt.figure()
            for i in range(n):
                data[i] = np.mean(self.rate[:, i]) # determine Rate for &#34;Plot Spectrum&#34;
                plt.rcParams[&#34;figure.figsize&#34;] = [6, 6] # plot window size
                plt.text(21.25, 28.1881, &#39;Detectors: &#39; + self.detectors, # display the information about detectors, set the text position on the plot
                         fontdict={&#39;fontsize&#39;: 7}) 
                plt.text(14.0,23.95, self.Date_start + &#39; to &#39; + self.Date_end, # + start &amp; end date of observed event, load directly from header
                         fontdict={&#39;fontsize&#39;: 7}) # set text size and font 
                plt.xlabel(&#39;Energy(keV)&#39;) # label X - axis
                plt.ylabel(&#39;counts/s&#39;) # Label Y - axis
                plt.title(&#39;SPEX HESSI Count Rate vs Energy&#39;) # plot title
        elif typ == &#39;counts&#39;:
            plt.figure()
            for i in range(n):
                data[i] = np.mean(self.rate[:, i] * self.sum) #determine Counts for &#34;Plot Spectrum&#34;
                plt.rcParams[&#34;figure.figsize&#34;] = [6, 6]
                plt.text(16.57, 69294, &#39;Detectors: &#39; + self.detectors, fontdict={&#39;fontsize&#39;: 7})
                plt.text(14, 60805, self.Date_start + &#39; to &#39; + self.Date_end,
                         fontdict={&#39;fontsize&#39;: 7})
                plt.xlabel(&#39;Energy(keV)&#39;)
                plt.ylabel(&#39;counts&#39;)
                plt.title(&#39;SPEX HESSI Counts vs Energy&#39;)
        elif typ == &#39;flux&#39;:
            plt.figure()
            deltaE = np.zeros(shape=(n))
            for i in range(n):
                deltaE[i] = self.E_max[i] - self.E_min[i] # energy range

            for i in range(n):
                data[i] = np.mean(self.rate[:, i]) / (self.Area * deltaE[i]-2) #determine Flux for &#34;Plot Spectrum&#34;
                plt.rcParams[&#34;figure.figsize&#34;] = [6, 6]
                plt.text(17.095, 0.1019, &#39;Detectors: &#39; + self.detectors, fontdict={&#39;fontsize&#39;: 7})
                plt.text(13.132, 0.088, self.Date_start + &#39; to &#39; + self.Date_end,
                         fontdict={&#39;fontsize&#39;: 7})
                plt.xlabel(&#39;Energy(keV)&#39;)
                plt.ylabel(&#39;counts s^(-1) cm^(-2) keV^(-1)&#39;)
                plt.title(&#39;SPEX HESSI Count Flux vs Energy&#39;)
        else:
            print(&#39;error&#39;)
            return
        #plt.figure()
        plt.plot(self.E_min, data, drawstyle=&#39;steps-post&#39;) #Unit vs Energy
        plt.yscale(&#39;log&#39;)
        plt.xscale(&#39;log&#39;)
        plt.show()

    # Plot:

    def plot_spectrum_rate(self):
        &#34;&#34;&#34;Plot spectrum for Rate&#34;&#34;&#34;
        self.__plot_spectrum(&#39;rate&#39;)

    def plot_spectrum_counts(self):
        &#34;&#34;&#34;Plot spectrum for Counts&#34;&#34;&#34;
        self.__plot_spectrum(&#39;counts&#39;)

    def plot_spectrum_flux(self):
        &#34;&#34;&#34;Plot spectrum for Flux&#34;&#34;&#34;
        self.__plot_spectrum(&#39;flux&#39;)

########################### 3. Spectrogram Plotting ################

    def __plot_spectrogram(self, typ):
        &#34;&#34;&#34;Spectrogram = function of Rate/Counts/Flux as a function of energy and time
        Parameters: x = tick(Time in h:m:s) and y(Energy bounds) are bounds, z is the value *inside* those bounds (Rate/Counts/Flux)&#34;&#34;&#34;
        tick = np.array([str(timedelta(seconds=s)) for s in self.Time2]) # rewrite the time array in a new format: hours:minutes:seconds
        # pcolormesh function(below) doesn&#39;t work with pandas time conversion function(TimeNew), that&#39;s why we rewrite it again
        #X, Y = np.meshgrid(tick, self.E_min)
        # Define Rate for Plot Spectrogram
        if typ == &#39;rate&#39;:
            plt.figure()
            plt.pcolormesh(tick, self.E_min, np.transpose(self.rate), cmap=&#39;gray_r&#39;) # cmap = color of the content
            # plt.xticks(np.arange(min(self.TimeNew), max(self.TimeNew), 1.0))
            plt.xlabel(&#39;Start Time: &#39; + self.Date_start) # to name the X -axis load the start date from header
            plt.ylabel(&#39;keV&#39;) # Y - axis: Energy in keV
            plt.title(&#39;SPEX HESSI Count Rate Spectrogram&#39;) # title name

        # Define Counts for Plot Spectrogram
        elif typ == &#39;counts&#39;:
            plt.figure()
            plt.pcolormesh(tick, self.E_min, np.transpose(self.rate) * self.sum, cmap=&#39;gray_r&#39;)
            plt.xlabel(&#39;Start Time: &#39; + self.Date_start)
            plt.ylabel(&#39;keV&#39;)
            plt.title(&#39;SPEX HESSI Counts Spectrogram&#39;)

        # Define Flux for Plot Spectrogram
        elif typ == &#39;flux&#39;:
            n = len(self.E_min)
            deltaE = np.zeros(shape=(n))
            for i in range(n):
                deltaE[i] = self.E_max[i] - self.E_min[i]
            plt.figure()
            plt.pcolormesh(tick, self.E_min, np.transpose(self.rate) / (self.Area * deltaE[i]), cmap=&#39;gray_r&#39;)
            plt.xlabel(&#39;Start Time: &#39; + self.Date_start)
            plt.ylabel(&#39;keV&#39;)
            plt.title(&#39;SPEX HESSI Count Flux Spectrogram&#39;)

        else:
            print(&#39;error&#39;)
            return
        #plt.axis([self.TimeNew2[0], self.TimeNew2[-1], 1, 1000])

        # plt.xsticks(rotation = 90)
        T = len(tick)/5 # step interval in X - axis(time)
        #FIXME: &#39;step&#39; calculation should be automated 
        plt.colorbar() # fix the colorbar (by default - vertically)
        plt.yscale(&#39;log&#39;) # specify in log
        plt.yticks([1, 1000]) # place plot content between 1 and 1000 in Y - axis
        plt.xticks(np.arange(len(tick), step = T)) # plot X -axis with given time and step = 8 minutes(08:00:00, 08:08:00, 08:16:00 and etc)
        # for 1st data: step = 30 # , rotation = 90)
        plt.show()

    # Plot Spectrogram for Rate
    def plot_spectrogram_rate(self):
        &#34;&#34;&#34;Plot Spectrogram for Rate&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;rate&#39;)

    def plot_spectrogram_counts(self):
        &#34;&#34;&#34;Plot Spectrogram for Counts&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;counts&#39;)

    # Plot spectrogram for Flux
    def plot_spectrogram_flux(self):
        &#34;&#34;&#34;Spectrogram for Flux&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;flux&#39;)

# testing
if __name__ == &#39;__main__&#39;:
    plots = Input(&#34;.fits&#34;) #any input file with .fits extension
    plots.rate_vs_time_plotting() #plot Count Rate vs Time
    plots.counts_vs_time_plotting() #plot Counts vs Time
    plots.flux_vs_time_plotting() #plot Count Flux vs Time
    plots.plot_spectrum_rate() #plot Count Rate vs Energy
    plots.plot_spectrum_counts() #plot Counts vs Energy
    plots.plot_spectrum_flux() #plot Flux vs Energy
    plots.plot_spectrogram_rate() #plot Count Rate Spectrogram
    plots.plot_spectrogram_counts() #plot Counts Spectrogram
    plots.plot_spectrogram_flux() #plot Flux Spectrogram</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="plotting.Input"><code class="flex name class">
<span>class <span class="ident">Input</span></span>
<span>(</span><span>file)</span>
</code></dt>
<dd>
<section class="desc"><p>Class to load the parameters from input data and plot Spectrum, Time Profile and Spectrogram.
Called Units: Rate, Counts, Flux.</p>
<p>When open the .fits file, the returned object, called hdulist, behaves like a Python list and each element maps
to a Header - Data Unit(HDU). We are primarily interested in RATE extension which contains the spectral data.
Extracted object has two important attributes: data, which behaves like an array, can be used to access to the numerical data;
and header, which behaves like a dictionary, can be used to access to the header information</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Input():
    &#34;&#34;&#34;Class to load the parameters from input data and plot Spectrum, Time Profile and Spectrogram.
       Called Units: Rate, Counts, Flux.&#34;&#34;&#34;
  
    def __init__(self, file):
        &#34;&#34;&#34;When open the .fits file, the returned object, called hdulist, behaves like a Python list and each element maps
        to a Header - Data Unit(HDU). We are primarily interested in RATE extension which contains the spectral data.
        Extracted object has two important attributes: data, which behaves like an array, can be used to access to the numerical data;
        and header, which behaves like a dictionary, can be used to access to the header information&#34;&#34;&#34;
        data1, data2, header3, header1 = self.__load_data(file) 

        # Define the parameters from HEADER and DATA
        # access by keywords
        self.rate = data1.RATE # count rate data in each energy channel
        self.Time = data1.TIME # array of Time(in seconds) corresponds to the observed flare
        self.Time2 = data1.TIME - 2 # FIXME: used to scale the X - axis in Time profile and Spectrogram plots - 2 seconds difference
        self.Time_del = data1.TIMEDEL # accumulation time
        self.Channel = data1.CHANNEL # energy channels
        self.E_min = data2.E_MIN # array of Low energies
        self.E_max = data2.E_MAX # array of High energies
        self.time_len = len(self.Time) # time length (time bins) 
        self.Area = header3[24] # load the area from header 
        self.Date_start = header3[17] # load start date from header
        self.Date_end = header3[18] # load end date from header
        self.E1 = self.E_min[3] - self.E_min[0] # highlight energy range from 3 to 6 kEv
        self.E2 = self.E_min[9] - self.E_min[3] # highlight energy range from 6 to 12 kEv
        self.E3 = self.E_min[22] - self.E_min[9] # highlight energy range from 12 to 25 kEv
        self.E4 = self.E_min[40] - self.E_min[22] # highlight energy range from 25 to 49 kEv
        self.E5 = self.E_min[57] - self.E_min[40] # highlight energy range from 49 to 100 kEv
        self.E6 = self.E_min[76] - self.E_min[57] # highlight energy range from 100 to 250 kEv
        self.sum = sum(self.Time_del) # observed event duration (in seconds)
        self.detectors = str(header1[25])[10:] # load the names of used detectors 

        # Time format conversion for Time - 2, 2 seconds difference
        # conversion from seconds to hours/minutes/seconds
        self.TimeNew2 = pd.to_datetime(self.Time2, unit=&#39;s&#39;)

    def __load_data(self, file):
        &#34;&#34;&#34;Loading the input file choosen in &#39;Select Input&#39; section&#34;&#34;&#34;
        hdulist = fits.open(file) # read the data
        hdulist.info() # display the content of the read file
        return hdulist[1].data, hdulist[2].data, hdulist[1].header, hdulist[3].header  #read the Data and Header contents from input file

################### 1. Time Profile Plotting ####################

    def __get_rate_data(self):
        &#34;&#34;&#34;Define the Rate for &#34;Plot Time Profile&#34;
        Rate  = array which has a count rate data for each energy channel
        There are 6 energy channels
        1: 3-6 kEV
        2: 6-12 keV
        3: 12-25 keV
        4: 25-49 keV
        5: 49-100 keV
        6: 100-250 keV &#34;&#34;&#34;
        data = np.zeros(shape=(self.time_len, 6))
        for i in range(self.time_len):
            # determine the energy distribution for different channels relative to the time of observed data
            data[i, 0] = sum(self.rate[i, 0:3]) #energy channel = 3-6 kEV
            data[i, 1] = sum(self.rate[i, 3:9]) #6-12 keV
            data[i, 2] = sum(self.rate[i, 9:22]) #12-25 keV
            data[i, 3] = sum(self.rate[i, 22:40]) #25-49 keV
            data[i, 4] = sum(self.rate[i, 40:57]) #49-100 keV
            data[i, 5] = sum(self.rate[i, 57:76]) #100-250 keV
        return data #return Rate unit

    def __get_counts_data(self):
        &#34;&#34;&#34;Define the Counts for &#34;Plot Time Profile&#34;
        In order to perform the conversion between Rate and Counts, multiply accumulation time by Rate&#34;&#34;&#34;
        data = np.zeros(shape=(self.time_len, 6))
        for i in range(self.time_len):
            data[i, 0] = sum(self.rate[i, 0:3]) * self.Time_del[i]
            data[i, 1] = sum(self.rate[i, 3:9]) * self.Time_del[i]
            data[i, 2] = sum(self.rate[i, 9:22]) * self.Time_del[i]
            data[i, 3] = sum(self.rate[i, 22:40]) * self.Time_del[i]
            data[i, 4] = sum(self.rate[i, 40:57]) * self.Time_del[i]
            data[i, 5] = sum(self.rate[i, 57:76]) * self.Time_del[i]
        return data #return Counts unit

    def __get_flux_data(self):
        &#34;&#34;&#34;Define the Flux for &#34;Plot Time Profile&#34;
        In order to convert Rate to count flux, divide the Rate by Area and Energy bin width&#34;&#34;&#34;
        data = np.zeros(shape=(self.time_len, 6))
        for i in range(self.time_len):
            data[i, 0] = sum(self.rate[i, 0:3]) / (self.Area * self.E1)
            data[i, 1] = sum(self.rate[i, 3:9]) / (self.Area * self.E2)
            data[i, 2] = sum(self.rate[i, 9:22]) / (self.Area * self.E3)
            data[i, 3] = sum(self.rate[i, 22:40]) / (self.Area * self.E4)
            data[i, 4] = sum(self.rate[i, 40:57]) / (self.Area * self.E5)
            data[i, 5] = sum(self.rate[i, 57:76]) / (self.Area * self.E6)
        return data #return Flux unit

    

    # 1. Plot Time Profile for Rate, Counts, Flux
    def __time_profile_plotting(self, data, xlabel, title, show=True, name=None):
        &#34;&#34;&#34;Plotting the function of time by selected Unit&#34;&#34;&#34;
        df = pd.DataFrame(data, index=self.TimeNew2,
                          columns=[&#39;3-6keV(Data with Bk)&#39;, &#39;6-12keV(Data with Bk)&#39;, &#39;12-25keV(Data with Bk)&#39;,
                                   &#39;25-49keV(Data with Bk)&#39;, &#39;49-100keV(Data with Bk)&#39;, &#39;100-250keV(Data with Bk)&#39;]) # add labels for each energy channel
        colors = [&#39;gray&#39;,&#39;magenta&#39;,&#39;lime&#39;, &#39;cyan&#39;, &#39;yellow&#39;, &#39;red&#39;] #choose the specific color for each energy channel 
        #df.style.set_properties(subset=[&#39;columns&#39;], **{&#39;height&#39;: &#39;50px&#39;})
        df.plot(figsize=(6, 6), drawstyle=&#39;steps-post&#39;, color = colors) # set the size of the figure 
        # define where the steps should be placed: &#39;steps-pre&#39;: The y value is continued constantly to the left from
        # every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]
        # &#39;steps-post&#39;: The y value is continued constantly to the right from every x position, i.e. the interval [x[i], x[i+1]) has the value y[i]
        # &#39;steps-mid&#39;: Steps occur half-way between the x positions
        #plt.rc(&#39;legend&#39;, labelsize=6)
        plt.yscale(&#39;log&#39;) # set Y-axis in log
        plt.xlabel(&#39;Start time: &#39; + str(self.Date_start)) # load start time from header and display it in X - axis
        plt.ylabel(xlabel)
        plt.title(title)
        #plt.text(self.x_position, 166, &#39;Detectors: &#39; + self.detectors) #rate
        #plt.text(self.x_position, 664, &#39;Detectors: &#39; + self.detectors)  # counts
        #plt.text(self.x_position, 0.023, &#39;Detectors: &#39; + self.detectors) #flux
        if show:
            plt.show()
        if name:
            plt.savefig(name, format=&#39;png&#39;)

    # if Rate, plot:
    def rate_vs_time_plotting(self):
        &#34;&#34;&#34;If user pick Rate in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
        rate_data = self.__get_rate_data()
        self.__time_profile_plotting(rate_data, &#39;counts/s&#39;, &#39;SPEX HESSI Count Rate vs Time&#39;) # name Y -axis and title for Rate 

    # if Counts:
    def counts_vs_time_plotting(self):
        &#34;&#34;&#34;If user pick Counts in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
        count_data = self.__get_counts_data()

        self.__time_profile_plotting(count_data, &#39;counts&#39;, &#39;SPEX HESSI Counts vs Time&#39;) # name Y -axis and title for Counts 

    # if Flux:
    def flux_vs_time_plotting(self):
        &#34;&#34;&#34;If user pick Flux in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
        flux_data = self.__get_flux_data()
        self.__time_profile_plotting(flux_data, &#39;counts s^(-1) cm^(-2) keV^(-1)&#39;, &#39;SPEX HESSI Count Flux vs Time&#39;) # name Y -axis and title for Flux

############################# 2. Spectrum plotting #################

    def __plot_spectrum(self, typ):
        &#34;&#34;&#34;As a photons come in over the time and with different energies, the spectrum of counts is built up
        Spectrum = function of energies for Rate/Counts/Flux&#34;&#34;&#34;
        n = len(self.E_min)
        data = np.zeros(shape=n) 
        if typ == &#39;rate&#39;:
            plt.figure()
            for i in range(n):
                data[i] = np.mean(self.rate[:, i]) # determine Rate for &#34;Plot Spectrum&#34;
                plt.rcParams[&#34;figure.figsize&#34;] = [6, 6] # plot window size
                plt.text(21.25, 28.1881, &#39;Detectors: &#39; + self.detectors, # display the information about detectors, set the text position on the plot
                         fontdict={&#39;fontsize&#39;: 7}) 
                plt.text(14.0,23.95, self.Date_start + &#39; to &#39; + self.Date_end, # + start &amp; end date of observed event, load directly from header
                         fontdict={&#39;fontsize&#39;: 7}) # set text size and font 
                plt.xlabel(&#39;Energy(keV)&#39;) # label X - axis
                plt.ylabel(&#39;counts/s&#39;) # Label Y - axis
                plt.title(&#39;SPEX HESSI Count Rate vs Energy&#39;) # plot title
        elif typ == &#39;counts&#39;:
            plt.figure()
            for i in range(n):
                data[i] = np.mean(self.rate[:, i] * self.sum) #determine Counts for &#34;Plot Spectrum&#34;
                plt.rcParams[&#34;figure.figsize&#34;] = [6, 6]
                plt.text(16.57, 69294, &#39;Detectors: &#39; + self.detectors, fontdict={&#39;fontsize&#39;: 7})
                plt.text(14, 60805, self.Date_start + &#39; to &#39; + self.Date_end,
                         fontdict={&#39;fontsize&#39;: 7})
                plt.xlabel(&#39;Energy(keV)&#39;)
                plt.ylabel(&#39;counts&#39;)
                plt.title(&#39;SPEX HESSI Counts vs Energy&#39;)
        elif typ == &#39;flux&#39;:
            plt.figure()
            deltaE = np.zeros(shape=(n))
            for i in range(n):
                deltaE[i] = self.E_max[i] - self.E_min[i] # energy range

            for i in range(n):
                data[i] = np.mean(self.rate[:, i]) / (self.Area * deltaE[i]-2) #determine Flux for &#34;Plot Spectrum&#34;
                plt.rcParams[&#34;figure.figsize&#34;] = [6, 6]
                plt.text(17.095, 0.1019, &#39;Detectors: &#39; + self.detectors, fontdict={&#39;fontsize&#39;: 7})
                plt.text(13.132, 0.088, self.Date_start + &#39; to &#39; + self.Date_end,
                         fontdict={&#39;fontsize&#39;: 7})
                plt.xlabel(&#39;Energy(keV)&#39;)
                plt.ylabel(&#39;counts s^(-1) cm^(-2) keV^(-1)&#39;)
                plt.title(&#39;SPEX HESSI Count Flux vs Energy&#39;)
        else:
            print(&#39;error&#39;)
            return
        #plt.figure()
        plt.plot(self.E_min, data, drawstyle=&#39;steps-post&#39;) #Unit vs Energy
        plt.yscale(&#39;log&#39;)
        plt.xscale(&#39;log&#39;)
        plt.show()

    # Plot:

    def plot_spectrum_rate(self):
        &#34;&#34;&#34;Plot spectrum for Rate&#34;&#34;&#34;
        self.__plot_spectrum(&#39;rate&#39;)

    def plot_spectrum_counts(self):
        &#34;&#34;&#34;Plot spectrum for Counts&#34;&#34;&#34;
        self.__plot_spectrum(&#39;counts&#39;)

    def plot_spectrum_flux(self):
        &#34;&#34;&#34;Plot spectrum for Flux&#34;&#34;&#34;
        self.__plot_spectrum(&#39;flux&#39;)

########################### 3. Spectrogram Plotting ################

    def __plot_spectrogram(self, typ):
        &#34;&#34;&#34;Spectrogram = function of Rate/Counts/Flux as a function of energy and time
        Parameters: x = tick(Time in h:m:s) and y(Energy bounds) are bounds, z is the value *inside* those bounds (Rate/Counts/Flux)&#34;&#34;&#34;
        tick = np.array([str(timedelta(seconds=s)) for s in self.Time2]) # rewrite the time array in a new format: hours:minutes:seconds
        # pcolormesh function(below) doesn&#39;t work with pandas time conversion function(TimeNew), that&#39;s why we rewrite it again
        #X, Y = np.meshgrid(tick, self.E_min)
        # Define Rate for Plot Spectrogram
        if typ == &#39;rate&#39;:
            plt.figure()
            plt.pcolormesh(tick, self.E_min, np.transpose(self.rate), cmap=&#39;gray_r&#39;) # cmap = color of the content
            # plt.xticks(np.arange(min(self.TimeNew), max(self.TimeNew), 1.0))
            plt.xlabel(&#39;Start Time: &#39; + self.Date_start) # to name the X -axis load the start date from header
            plt.ylabel(&#39;keV&#39;) # Y - axis: Energy in keV
            plt.title(&#39;SPEX HESSI Count Rate Spectrogram&#39;) # title name

        # Define Counts for Plot Spectrogram
        elif typ == &#39;counts&#39;:
            plt.figure()
            plt.pcolormesh(tick, self.E_min, np.transpose(self.rate) * self.sum, cmap=&#39;gray_r&#39;)
            plt.xlabel(&#39;Start Time: &#39; + self.Date_start)
            plt.ylabel(&#39;keV&#39;)
            plt.title(&#39;SPEX HESSI Counts Spectrogram&#39;)

        # Define Flux for Plot Spectrogram
        elif typ == &#39;flux&#39;:
            n = len(self.E_min)
            deltaE = np.zeros(shape=(n))
            for i in range(n):
                deltaE[i] = self.E_max[i] - self.E_min[i]
            plt.figure()
            plt.pcolormesh(tick, self.E_min, np.transpose(self.rate) / (self.Area * deltaE[i]), cmap=&#39;gray_r&#39;)
            plt.xlabel(&#39;Start Time: &#39; + self.Date_start)
            plt.ylabel(&#39;keV&#39;)
            plt.title(&#39;SPEX HESSI Count Flux Spectrogram&#39;)

        else:
            print(&#39;error&#39;)
            return
        #plt.axis([self.TimeNew2[0], self.TimeNew2[-1], 1, 1000])

        # plt.xsticks(rotation = 90)
        T = len(tick)/5 # step interval in X - axis(time)
        #FIXME: &#39;step&#39; calculation should be automated 
        plt.colorbar() # fix the colorbar (by default - vertically)
        plt.yscale(&#39;log&#39;) # specify in log
        plt.yticks([1, 1000]) # place plot content between 1 and 1000 in Y - axis
        plt.xticks(np.arange(len(tick), step = T)) # plot X -axis with given time and step = 8 minutes(08:00:00, 08:08:00, 08:16:00 and etc)
        # for 1st data: step = 30 # , rotation = 90)
        plt.show()

    # Plot Spectrogram for Rate
    def plot_spectrogram_rate(self):
        &#34;&#34;&#34;Plot Spectrogram for Rate&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;rate&#39;)

    def plot_spectrogram_counts(self):
        &#34;&#34;&#34;Plot Spectrogram for Counts&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;counts&#39;)

    # Plot spectrogram for Flux
    def plot_spectrogram_flux(self):
        &#34;&#34;&#34;Spectrogram for Flux&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;flux&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="plotting.Input.counts_vs_time_plotting"><code class="name flex">
<span>def <span class="ident">counts_vs_time_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>If user pick Counts in 'Plot Units' section, plot 'Time profile':</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counts_vs_time_plotting(self):
    &#34;&#34;&#34;If user pick Counts in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
    count_data = self.__get_counts_data()

    self.__time_profile_plotting(count_data, &#39;counts&#39;, &#39;SPEX HESSI Counts vs Time&#39;) # name Y -axis and title for Counts </code></pre>
</details>
</dd>
<dt id="plotting.Input.flux_vs_time_plotting"><code class="name flex">
<span>def <span class="ident">flux_vs_time_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>If user pick Flux in 'Plot Units' section, plot 'Time profile':</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flux_vs_time_plotting(self):
    &#34;&#34;&#34;If user pick Flux in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
    flux_data = self.__get_flux_data()
    self.__time_profile_plotting(flux_data, &#39;counts s^(-1) cm^(-2) keV^(-1)&#39;, &#39;SPEX HESSI Count Flux vs Time&#39;) # name Y -axis and title for Flux</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrogram_counts"><code class="name flex">
<span>def <span class="ident">plot_spectrogram_counts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot Spectrogram for Counts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrogram_counts(self):
    &#34;&#34;&#34;Plot Spectrogram for Counts&#34;&#34;&#34;
    self.__plot_spectrogram(&#39;counts&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrogram_flux"><code class="name flex">
<span>def <span class="ident">plot_spectrogram_flux</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Spectrogram for Flux</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrogram_flux(self):
    &#34;&#34;&#34;Spectrogram for Flux&#34;&#34;&#34;
    self.__plot_spectrogram(&#39;flux&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrogram_rate"><code class="name flex">
<span>def <span class="ident">plot_spectrogram_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot Spectrogram for Rate</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrogram_rate(self):
    &#34;&#34;&#34;Plot Spectrogram for Rate&#34;&#34;&#34;
    self.__plot_spectrogram(&#39;rate&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrum_counts"><code class="name flex">
<span>def <span class="ident">plot_spectrum_counts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot spectrum for Counts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrum_counts(self):
    &#34;&#34;&#34;Plot spectrum for Counts&#34;&#34;&#34;
    self.__plot_spectrum(&#39;counts&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrum_flux"><code class="name flex">
<span>def <span class="ident">plot_spectrum_flux</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot spectrum for Flux</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrum_flux(self):
    &#34;&#34;&#34;Plot spectrum for Flux&#34;&#34;&#34;
    self.__plot_spectrum(&#39;flux&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrum_rate"><code class="name flex">
<span>def <span class="ident">plot_spectrum_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot spectrum for Rate</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrum_rate(self):
    &#34;&#34;&#34;Plot spectrum for Rate&#34;&#34;&#34;
    self.__plot_spectrum(&#39;rate&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.rate_vs_time_plotting"><code class="name flex">
<span>def <span class="ident">rate_vs_time_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>If user pick Rate in 'Plot Units' section, plot 'Time profile':</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate_vs_time_plotting(self):
    &#34;&#34;&#34;If user pick Rate in &#39;Plot Units&#39; section, plot &#39;Time profile&#39;:&#34;&#34;&#34;
    rate_data = self.__get_rate_data()
    self.__time_profile_plotting(rate_data, &#39;counts/s&#39;, &#39;SPEX HESSI Count Rate vs Time&#39;) # name Y -axis and title for Rate </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="plotting.Input" href="#plotting.Input">Input</a></code></h4>
<ul class="">
<li><code><a title="plotting.Input.counts_vs_time_plotting" href="#plotting.Input.counts_vs_time_plotting">counts_vs_time_plotting</a></code></li>
<li><code><a title="plotting.Input.flux_vs_time_plotting" href="#plotting.Input.flux_vs_time_plotting">flux_vs_time_plotting</a></code></li>
<li><code><a title="plotting.Input.plot_spectrogram_counts" href="#plotting.Input.plot_spectrogram_counts">plot_spectrogram_counts</a></code></li>
<li><code><a title="plotting.Input.plot_spectrogram_flux" href="#plotting.Input.plot_spectrogram_flux">plot_spectrogram_flux</a></code></li>
<li><code><a title="plotting.Input.plot_spectrogram_rate" href="#plotting.Input.plot_spectrogram_rate">plot_spectrogram_rate</a></code></li>
<li><code><a title="plotting.Input.plot_spectrum_counts" href="#plotting.Input.plot_spectrum_counts">plot_spectrum_counts</a></code></li>
<li><code><a title="plotting.Input.plot_spectrum_flux" href="#plotting.Input.plot_spectrum_flux">plot_spectrum_flux</a></code></li>
<li><code><a title="plotting.Input.plot_spectrum_rate" href="#plotting.Input.plot_spectrum_rate">plot_spectrum_rate</a></code></li>
<li><code><a title="plotting.Input.rate_vs_time_plotting" href="#plotting.Input.rate_vs_time_plotting">rate_vs_time_plotting</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>